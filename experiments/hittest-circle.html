<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <style>
    * {
      padding: 0;
      margin: 0;
      box-sizing: border-box;
    }
  </style>
  <canvas></canvas>
  <script type="module">

    export const isLeftOf = (hitboxA, hitboxB) => hitboxA.x >= hitboxB.x
    export const isAbove = (hitboxA, hitboxB) => hitboxA.y >= hitboxB.y
    export const isLine = (hitbox) => hitbox.x === hitbox.x2 || hitbox.y === hitbox.y2
    export const distanceBetweenPoints = (x, y, x2, y2) => {
      const minx = Math.min(x, x2)
      const maxx = Math.max(x, x2)
      const miny = Math.min(y, y2)
      const maxy = Math.max(y, y2)
      return Math.sqrt(
        Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2)
      )
    }
    export const pointInBox = ([x, y], hitbox) => {
      // console.log(x, y)
      return x >= hitbox.x
        && x <= hitbox.x2
        && y >= hitbox.y
        && y <= hitbox.y2;
    }
    export const pointInCircle = ([x, y], circle) => {
      const { radius } = circle;
      const xs = circle.originX - x;
      const ys = circle.originY - y;
      return ((xs * xs) + (ys * ys)) < (radius * radius);
      // return distanceBetweenPoints(x, y, circle.x, circle.y) < circle.radius;
    }
    export const hittestRect = (hitboxA, hitboxB) => {
      if (isLine(hitboxA) || isLine(hitboxB)) return false
        if (hitboxB.x >= hitboxA.x2) return false
        if (hitboxA.x >= hitboxB.x2) return false
        if (hitboxB.y >= hitboxA.y2) return false
        if (hitboxA.y >= hitboxB.y2) return false
        return true
    }
    
    export const hittestCircles = (circleA, circleB) => {
      return distanceBetweenPoints(
        circleA.originX,
        circleA.originY,
        circleB.originX,
        circleB.originY,
      ) < (circleA.radius + circleB.radius)
    }
    export const hittestRectCircle = (hitboxA, hitboxB) => {
      const isHitboxARect = hitboxA.type === 'rect';
      const box = isHitboxARect ? hitboxA : hitboxB
      const circle = isHitboxARect ? hitboxB : hitboxA
      if (isLine(box)) return false;
      for (let pos of circle.interactionPoints) {
        if (pointInBox(pos, box)) return true;
      }
      for (let pos of box.interactionPoints) {
        if (pointInCircle(pos, circle)) return true;
      }
      return false
    }
    export const hittest = (hitboxA, hitboxB) => {
      const atype = hitboxA.type;
      const btype = hitboxB.type;
      if (atype === 'rect' && btype === 'rect') return hittestRect(hitboxA, hitboxB);
      if (atype === 'circle' && btype === 'circle') return hittestCircles(hitboxA, hitboxB);
      return hittestRectCircle(hitboxA, hitboxB);
    }

    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');

    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas)
    resizeCanvas()

    const mouseMoveEvents = new Set();
    canvas.addEventListener('mousemove', (e) => {
      mouseMoveEvents.forEach(event => event([e.offsetX, e.offsetY]))
    })
    const dot = ([x, y]) => {
      const item = new Path2D();
      item.arc(x, y, 2, 0,  2 * Math.PI);
      ctx.save()
      ctx.fillStyle = 'black'
      ctx.fill(item)
      ctx.restore();
    }
    const getRectBoundingBox = ({ pos, size }) => {
        const [x, y] = pos;
        const [width, height] = size;
        const x2 = x + width;
        const y2 = y + height;
        const interactionPoints = [
          [x, y], [x2, y],
          [x, y2], [x2, y2],
        ]
        return {
          type: 'rect',
          x,
          y,
          x2,
          y2,
          interactionPoints,
        };
      
    }
    const getCircleBoundingBox = ({pos, radius}) => {
        const type = 'circle';
        const originX = pos[0];
        const originY = pos[1];
        const x = pos[0] - radius;
        const y = pos[1] - radius;
        const x2 = pos[0] + radius;
        const y2 = pos[1] + radius;
        const width = radius * 2;
        const height = radius * 2;
        const interactionPoints = [
                [originX, y],
          [x, originY],         [x2, originY],
                [originX, y2],
        ]
        return {
          type,
          radius,
          originX,
          originY,
          x,
          y,
          x2,
          y2,
          width,
          height,
          interactionPoints,
        };
    }
    class Circle {
      constructor(x, y, radius) {
        this.pos = [x, y]
        this.radius = radius;
        this.touching = false
      }
      update() {
        // if (!getCircleBoundingBox(this) || !getCircleBoundingBox(circle)) {
        //   console.log(getCircleBoundingBox(this), getCircleBoundingBox(circle));
        // }
        this.touching = hittestCircles(getCircleBoundingBox(this), getCircleBoundingBox(circle))
      }
      render() {
        const { pos, mousePos, radius } = this
        const item = new Path2D();
        item.arc(pos[0], pos[1], radius, 0,  2 * Math.PI);
        ctx.save()
        ctx.fillStyle = 'rgba(0, 255, 0, .5)'
        if (this.touching) {
          ctx.fillStyle = 'rgba(255, 0, 0, .5)'
        }
        ctx.fill(item)
        ctx.restore();
      }
    }
    class Box {
      constructor(x, y, width, height) {
        this.pos = [x, y]
        this.size = [width, height]
        this.hitCirclePass = false;
      }
      update() {
        this.hitCirclePass = false;
        if (hittestRectCircle(getRectBoundingBox(this), getCircleBoundingBox(circle))) {
          this.hitCirclePass = true
        }
      }
      
      render(ctx) {
        const [x, y] = this.pos;
        const [width, height] = this.size;
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = 'rgba(0, 0, 255, .25)'
        if (this.hitCirclePass) {
          ctx.fillStyle = 'rgba(255, 0, 0, .5)'
        }
        ctx.fillRect(x, y, width, height)
        ctx.closePath();
        ctx.restore();
        for (let pos of getRectBoundingBox(this).interactionPoints) {
          dot(pos)
        }
      }
    }
    
    class User {
      constructor(){
        this.pos = [0, 0];
        this.radius = 100;

        mouseMoveEvents.add((mousePos) => { this.pos = mousePos });
      }
      update() {}
      renderMain(ctx) {
        const { pos, radius } = this
        const item = new Path2D();
        item.arc(pos[0], pos[1], radius, 0,  2 * Math.PI);
        ctx.save()
        ctx.fillStyle = 'rgba(0, 255, 0, .5)'
        ctx.fill(item)
        ctx.restore();
      }
      renderBoundingBox(ctx) {
        const { x, y, width, height } = getCircleBoundingBox(this)
        const path = new Path2D();
        path.rect(x, y, width, height)
        ctx.save()
        ctx.strokeStyle = 'red'
        ctx.stroke(path);
        ctx.restore();
      }
      render(ctx) {
        this.renderMain(ctx);
        this.renderBoundingBox(ctx);
        for (let pos of getCircleBoundingBox(this).interactionPoints) {
          dot(pos);
        }
      }
    }
    const circle = new User();
    const boxes = []
    for (let i = 0; i < 10; i++) {
      const w = 50 + (Math.random() * 50);
      const h = 50 + (Math.random() * 50);
      const x = Math.random() * (canvas.width - w);
      const y = Math.random() * (canvas.height - h);
      boxes.push(new Box(x, y, w, h));
    }
    const circles = []
    for (let i = 0; i < 1; i++) {
      const radius = 25 + (Math.random() * 25);
      const x = radius + (Math.random() * (canvas.width - radius));
      const y = radius + (Math.random() * (canvas.height - radius));
      circles.push(new Circle(x, y, radius));
    }
    const gameObjects = [
      ...boxes,
      circle,
      ...circles
      // new Circle(),
      // new PointCircleHittest()
    ];
    const render = () => {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      gameObjects.forEach(obj => obj && obj.update && obj.update());
      gameObjects.forEach(obj => obj && obj.render && obj.render(ctx));
      window.requestAnimationFrame(render);
    }
    render()
  </script>
</body>
</html>